<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java三种编译方式]]></title>
    <url>%2F2020%2F03%2F02%2FJava%E4%B8%89%E7%A7%8D%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前端编译 JIT编译 AOT编译 前端编译把Java源码文件（.java）编译成Class文件(.class)的过程；也即把满足Java语言规范的程序转化为满足JVM规范所要求格式的功能； 优点： 这阶段的优化是指程序编码方面的； 许多Java语法新特性（”语法糖”：泛型、内部类等等），是靠前端编译器实现的,而不是依赖虚拟机； 编译成的Class文件可以直接给JVM解释器解释执行，省去编译时间，加快启动速度； 缺点： 对代码运行效率几乎没有任何优化措施； 解释执行效率较低，所以需要结合下面的JIT编译； 前端编译器：Oracle javac、Eclipse JDT中的增量式编译器（ECJ）等; 后端编译/即时(JIT)编译通过Java虚拟机（JVM）内置的即时编译器（Just In Time Compiler，JIT编译器）；在运行时把Class文件字节码编译成本地机器码的过程； 优点： 通过在运行时收集监控信息，把”热点代码”（Hot Spot Code）编译成与本地平台相关的机器码，并进行各种层次的优化； 可以大大提高执行效率； 缺点： 收集监控信息影响程序运行； 编译过程占用程序运行时间（如使得启动速度变慢）； 编译机器码占用内存； JIT编译器：HotSpot虚拟机的C1、C2编译器等； 另外，JIT编译速度及编译结果的优劣，是衡量一个JVM性能的很重要指标；所以对程序运行性能优化集中到这个阶段；也就是说可以对这个阶段进行JVM调优； 静态提前编译（Ahead Of Time，AOT编译）程序运行前，直接把Java源码文件（.java）编译成本地机器码的过程； 优点： 编译不占用运行时间，可以做一些较耗时的优化，并可加快程序启动； 把编译的本地机器码保存磁盘，不占用内存，并可多次使用； 缺点： 因为Java语言的动态性（如反射）带来了额外的复杂性，影响了静态编译代码的质量； 一般静态编译不如JIT编译的质量，这种方式用得比较少； 静态提前编译器（AOT编译器）：JAOTC、GCJ、Excelsior JET、ART (Android Runtime)等； 关于ART (Android Runtime)模式：ART虽然主要通过AOT编译支持Java的运行，但仍然带有解释器。 前端编译+JIT编译到这里，我们知道目前Java体系中主要还是采用前端编译+JIT编译的方式，如JDK中的HotSpot虚拟机。 前端编译+JIT编译方式的运作过程大体如下： 首先通过前端编译把符合Java语言规范的程序代码转化为满足JVM规范所要求Class格式； 然后程序启动时Class格式文件发挥作用，解释执行，省去编译时间，加快启动速度； 针对Class解释执行效率低的问题，在运行中收集性能监控信息，得知”热点代码”； JIT逐渐发挥作用，把越来越多的热点代码”编译优化成本地代码，提高执行效率；]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础知识点</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01谈谈你对Java平台的理解?[转]]]></title>
    <url>%2F2020%2F03%2F01%2FJava%E6%A0%B8%E5%BF%8336%E8%AE%B201%2F</url>
    <content type="text"><![CDATA[从你接触Java开发到现在，你对Java最直观的印象是什么呢？是它宣传的 “Write once, run anywhere”，还是目前看已经有些过于形式主义的语法呢？你对于Java平台到底了解到什么程度？请你先停下来总结思考一下。 今天我要问你的问题是，谈谈你对Java平台的理解？“Java是解释执行”，这句话正确吗？ 典型回答Java本身是一种面向对象的语言，最显著的特性有两个方面， 一是所谓的“书写一次，到处运行”（Write once, run anywhere），能够非常容易地获得跨平台能力； 另外就是垃圾收集（GC, Garbage Collection），Java通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。 我们日常会接触到JRE（Java Runtime Environment）或者JDK（Java Development Kit）。 JRE，也就是Java运行环境，包含了JVM和Java类库，以及一些模块等。而JDK可以看作是JRE的一个超集，提供了更多工具，比如编译器、各种诊断工具等。 对于“Java是解释执行”这句话，这个说法不太准确。 我们开发的Java的源代码， 首先通过Javac编译成为字节码（bytecode），然后，在运行时，通过 Java虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。 但是常见的JVM，比如我们大多数情况使用的Oracle JDK提供的Hotspot JVM，都提供了JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT能够在# 运行时将热点代码编译成机器码 #，这种情况下部分热点代码就属于编译执行，而不是解释执行了。 考点分析其实这个问题，问得有点笼统。题目本身是非常开放的，往往考察的是多个方面，比如，基础知识理解是否很清楚；是否掌握Java平台主要模块和运行原理等。很多面试者会在这种问题上吃亏，稍微紧张了一下，不知道从何说起，就给出个很简略的回答。 对于这类笼统的问题，你需要尽量表现出自己的思维深入并系统化，Java知识理解得也比较全面，一定要避免让面试官觉得你是个“知其然不知其所以然”的人。毕竟明白基本组成和机制，是日常工作中进行问题诊断或者性能调优等很多事情的基础，相信没有招聘方会不喜欢“热爱学习和思考”的面试者。 即使感觉自己的回答不是非常完善，也不用担心。我个人觉得这种笼统的问题，有时候回答得稍微片面也很正常，大多数有经验的面试官，不会因为一道题就对面试者轻易地下结论。通常会尽量引导面试者，把他的真实水平展现出来，这种问题就是做个开场热身，面试官经常会根据你的回答扩展相关问题。 知识扩展回归正题，对于Java平台的理解，可以从很多方面简明扼要地谈一下，例如： Java语言特性，包括泛型、Lambda等语言特性； 基础类库，包括集合、IO/NIO、网络、并发、安全等基础类库。对于我们日常工作应用较多的类库，面试前可以系统化总结一下，有助于临场发挥。 或者谈谈JVM的一些基础概念和机制，比如 Java的类加载机制，常用版本JDK（如JDK 8）内嵌的Class-Loader，例如Bootstrap、 Application和Extension Class-loader； 类加载大致过程：加载、验证、链接、初始化（这里参考了周志明的《深入理解Java虚拟机》，非常棒的JVM上手书籍）； 自定义Class-Loader等。 还有垃圾收集的基本原理，最常见的垃圾收集器，如SerialGC、Parallel GC、 CMS、 G1等，对于适用于什么样的工作负载最好也心里有数。这些都是可以扩展开的领域，我会在后面的专栏对此进行更系统的介绍。 当然还有JDK包含哪些工具或者Java领域内其他工具等，如编译器、运行时环境、安全工具、诊断和监控工具等。这些基本工具是日常工作效率的保证，对于我们工作在其他语言平台上，同样有所帮助，很多都是触类旁通的。 下图是我总结的一个相对宽泛的蓝图供你参考。 不再扩展了，回到前面问到的解释执行和编译执行的问题。 有些面试官喜欢在特定问题上“刨根问底儿”，因为这是进一步了解面试者对知识掌握程度的有效方法，我稍微深入探讨一下。 众所周知，我们通常把Java分为编译期和运行时。 这里说的Java的编译和C/C++是有着不同的意义的，Javac的编译，编译Java源码生成“.class”文件里面实际是字节码，而不是可以直接执行的机器码。Java通过字节码和Java虚拟机（JVM）这种跨平台的抽象，屏蔽了操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。 在运行时，JVM会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。就像我前面提到的，主流Java版本中，如JDK 8实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。通常运行在server模式的JVM，会进行上万次调用以收集足够的信息进行高效的编译，client模式这个门限是1500次。Oracle Hotspot JVM内置了两个不同的JIT compiler，C1对应前面说的client模式，适用于对于启动速度敏感的应用，比如普通Java桌面应用；C2对应server模式，它的优化是为长时间运行的服务器端应用设计的。默认是采用所谓的分层编译（TieredCompilation）。这里不再展开更多JIT的细节，没必要一下子就钻进去，我会在后面介绍分层编译的内容。 Java虚拟机启动时，可以指定不同的参数对运行模式进行选择。 比如， 指定“-Xint”，就是告诉JVM只进行解释执行，不对代码进行编译，这种模式抛弃了JIT可能带来的性能优势。毕竟解释器（interpreter）是逐条读入，逐条解释运行的。 与其相对应的，还有一个“-Xcomp”参数，这是告诉JVM关闭解释器，不要进行解释执行，或者叫作最大优化级别。那你可能会问这种模式是不是最高效啊？简单说，还真未必。“-Xcomp”会导致JVM启动变慢非常多，同时有些JIT编译器优化方式，比如分支预测，如果不进行profling，往往并不能进行有效优化。 除了我们日常最常见的Java使用模式，其实还有一种新的编译方式，即所谓的AOT（Ahead-of-Time Compilation），直接将字节码编译成机器代码，这样就避免了JIT预热等各方面的开销，比如Oracle JDK 9就引入了实验性的AOT特性，并且增加了新的jaotc工具。利用下面的命令把某个类或者某个模块编译成为AOT库。 jaotc --output libHelloWorld.so HelloWorld.class jaotc --output libjava.base.so --module java.base 然后，在启动时直接指定就可以了。 java -XX:AOTLibrary=./libHelloWorld.so,./libjava.base.so HelloWorld 而且，Oracle JDK支持分层编译和AOT协作使用，这两者并不是二选一的关系。如果你有兴趣，可以参考相关文档：http://openjdk.java.net/jeps/295 。AOT也不仅仅是只有这一种方式，业界早就有第三方工具（如GCJ、Excelsior JET）提供相关功能。 另外，JVM作为一个强大的平台，不仅仅只有Java语言可以运行在JVM上，本质上合规的字节码都可以运行，Java语言自身也为此提供了便利，我们可以看到类似Clojure、Scala、Groovy、JRuby、Jython等大量JVM语言，活跃在不同的场景。 今天，我简单介绍了一下Java平台相关的一些内容，目的是提纲挈领地构建一个整体的印象，包括Java语言特性、 核心类库与常用第三方类库、Java虚拟机基本原理和相关工具，希望对你有所帮助。 一课一练关于今天我们讨论的题目你做到心中有数了吗？知道不如做到，请你也在留言区写写自己对Java平台的理解。我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础专题</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
        <tag>Java核心36讲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的位运算^,&,,[转]]]></title>
    <url>%2F2020%2F02%2F29%2Fjava%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[^(亦或运算) ，针对二进制，相同的为0，不同的为1 123456789public static void main(String[] args) &#123; System.out.println(&quot;2^3运算的结果是 :&quot;+(2^3)); //打印的结果是: 2^3运算的结果是 :1&#125;2 =======&gt;00103 =======&gt;00112^3就为0001，结果就是1 &amp;（与运算） 针对二进制，只要有一个为0，就为0还是上述的例子 1234public static void main(String[] args) &#123; System.out.println(&quot;2&amp;3运算的结果是 :&quot;+(2&amp;3)); //打印的结果是: 2&amp;3运算的结果是 :2 &#125; &lt;&lt;(向左位移) 针对二进制，转换成二进制后向左移动3位，后面用0补齐1234public static void main(String[] args) &#123; System.out.println(&quot;2&lt;&lt;3运算的结果是 :&quot;+(2&lt;&lt;3)); //打印的结果是: 2&lt;&lt;3运算的结果是 :16 &#125; &gt;&gt;(向右位移) 针对二进制，转换成二进制后向右移动3位，1234public static void main(String[] args) &#123; System.out.println(&quot;2&gt;&gt;3运算的结果是 :&quot;+(2&gt;&gt;3)); //打印的结果是: 2&gt;&gt;3运算的结果是 :0 &#125; &gt;&gt;&gt;(无符号右移) 无符号右移，忽略符号位，空位都以0补齐10进制转二进制的时候，因为二进制数一般分8位、 16位、32位以及64位 表示一个十进制数，所以在转换过程中，最高位会补零。 在计算机中负数采用二进制的补码表示，10进制转为二进制得到的是源码，将源码按位取反得到的是反码，反码加1得到补码 二进制的最高位是符号位，0表示正，1表示负。 &gt;&gt;&gt;与&gt;&gt;唯一的不同是它无论原来的最左边是什么数，统统都用0填充。——比如，byte是8位的，-1表示为byte型是11111111(补码表示法）b&gt;&gt;&gt;4就是无符号右移4位，即00001111，这样结果就是15。下面看代码 123456789101112131415161718public static void main(String[] args) &#123; System.out.println(&quot;16&gt;&gt;2运算的结果是 :&quot;+((16)&gt;&gt;2)); //打印的结果是: 16&gt;&gt;2运算的结果是 :4&#125;public static void main(String[] args) &#123; System.out.println(&quot;-16&gt;&gt;2运算的结果是 :&quot;+((-16)&gt;&gt;2)); //打印的结果是: -16&gt;&gt;2运算的结果是 :-4 &#125;public static void main(String[] args) &#123; System.out.println(&quot;16&gt;&gt;&gt;2运算的结果是 :&quot;+((16)&gt;&gt;&gt;2)); //打印的结果是: 16&gt;&gt;&gt;2运算的结果是 :4 &#125;public static void main(String[] args) &#123; System.out.println(&quot;-16&gt;&gt;&gt;2运算的结果是 :&quot;+((-16)&gt;&gt;&gt;2)); //打印的结果是: -16&gt;&gt;&gt;2运算的结果是 :1073741820 &#125; 可见正数做&gt;&gt;&gt;运算的时候和&gt;&gt;是一样的。区别在于负数运算]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础知识点</category>
      </categories>
      <tags>
        <tag>阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[helloworld]]></title>
    <url>%2F2019%2F05%2F23%2Fhelloworld%2F</url>
    <content type="text"></content>
  </entry>
</search>
